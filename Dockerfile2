app = "your-app-name-here"

[build]
  # If using Dockerfile
  dockerfile = "Dockerfile"

[http_service]
  # If your service has a signaling HTTP endpoint or a health-check
  internal_port = 8080
  force_https = true


  FROM golang:1.21 as builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 go build -o server main.go

FROM debian:stable-slim
RUN apt-get update && apt-get install -y ffmpeg ca-certificates && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY --from=builder /app/server /app/server

# Expose a port if you have signaling on HTTP or similar
EXPOSE 8080

ENTRYPOINT ["/app/server"]


package main

import (
    "fmt"
    "io"
    "log"
    "os"
    "os/exec"
    "sync"

    "github.com/pion/webrtc/v3"
    "github.com/pion/webrtc/v3/pkg/media/ivfwriter"
)

// In a real application, you'd have signaling to create offers/answers and establish a PeerConnection.
// For brevity, assume we have a mechanism (like a simple websocket signaling) that provides us a remote SDP to setRemoteDescription.

func main() {
    // Create a named pipe for IVF output
    pipePath := "/tmp/output.ivf"
    os.Remove(pipePath) // remove if exists
    if err := os.Mkfifo(pipePath, 0600); err != nil {
        log.Fatalf("Failed to create named pipe: %v", err)
    }

    // Start ffmpeg: read IVF from pipe and write MP4
    // Assuming VP8 input, IVF stream from the pipe.
    // Adjust bitrate, codec, etc. as needed.
    ffmpegCmd := exec.Command("ffmpeg",
        "-y",              // overwrite output
        "-f", "ivf",
        "-i", pipePath,
        "-c:v", "libx264",
        "-pix_fmt", "yuv420p",
        "output.mp4",
    )

    ffmpegCmd.Stderr = os.Stderr
    ffmpegCmd.Stdout = os.Stdout

    if err := ffmpegCmd.Start(); err != nil {
        log.Fatalf("Failed to start ffmpeg: %v", err)
    }

    // Create a new PeerConnection
    config := webrtc.Configuration{}
    peerConnection, err := webrtc.NewPeerConnection(config)
    if err != nil {
        log.Fatalf("Failed to create PeerConnection: %v", err)
    }

    var pipeWriter io.WriteCloser
    var writerLock sync.Mutex

    peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
        // Only handle video track
        if track.Kind() == webrtc.RTPCodecTypeVideo {
            log.Println("Received a video track!")

            writerLock.Lock()
            if pipeWriter == nil {
                // Create IVF writer to write to the pipe
                w, err := os.OpenFile(pipePath, os.O_WRONLY, 0600)
                if err != nil {
                    log.Fatalf("Failed to open named pipe for writing: %v", err)
                }
                pipeWriter = w

                // IVF writer wraps the pipe writer
                ivf, err := ivfwriter.New(pipeWriter)
                if err != nil {
                    log.Fatalf("Failed to create IVF writer: %v", err)
                }

                go func() {
                    defer ivf.Close()
                    // Read RTP packets and write to IVF
                    for {
                        pkt, _, err := track.ReadRTP()
                        if err != nil {
                            log.Printf("Track ended: %v", err)
                            return
                        }
                        if err := ivf.WriteRTP(pkt); err != nil {
                            log.Printf("IVF write error: %v", err)
                            return
                        }
                    }
                }()
            }
            writerLock.Unlock()
        }
    })

    // In a real app, you'd set a remote description, add an ICE candidate handler, etc.
    // For demonstration, weâ€™ll just wait indefinitely.
    log.Println("Pion server running. Awaiting WebRTC tracks...")

    // Wait for SIGTERM or similar in production
    select {}
}


//pion -> fly.io -> google drive